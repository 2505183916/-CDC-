<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>canvas五子棋</title>
	<style>
		/*棋子板{*/

		#chess {
			display: block;
			position: absolute;
			top: 237px;
		}
		/*}棋子板*/
		/*背景板{*/

		#bgchess {
			display: block;
			border: 1px solid black;
		}
		/*}背景板*/
		/*按钮位置{*/
		#g-footer{
			margin-top: 30px;
			margin-left: 120px;
		}
		#g-footer button {
			height: 30px;
			width: 100px;
		}
		/*}按钮位置*/
	</style>
</head>

<body>
	<h1>HTML5 Canvas实现的五子棋</h1>
	<h3>@Author：黄俊豪<br> @应聘：前端开发
		<br> @经验：实习经验：1.5年
		<br> @过往公司：广州唯品会
		<br> @电话：131-4584-2547
		<br>
	</h3>
	<canvas id="bgchess" width="450px" height="450px">你的浏览器不支持HTML5 canvas,请使用最新版Chrome浏览器打开.</canvas>
	<canvas id="chess" width="450px" height="450px"></canvas>
	<div id="g-footer">
		<button type="button" id="revert" onclick="revert()">悔棋</button>
		<button type="button" id="removeRevert" onclick="removeRevert()">撤销悔棋</button>
	</div>
	<script>
		/*DOM实现五子棋
		@Author：黄俊豪
		@应聘：前端开发
		@经验：实习经验：1.5年；
		@过往公司：广州唯品会
		@电话：131-4584-2547
		*/

		//模拟JQ的写法，提高获取元素效率
		var $ = document.querySelectorAll.bind(document);

		//本人偏向于把所有变量放入config中，减少全局变量数量
		var config = {
			chessBoard: [],//二维数组用来保存棋盘信息，0为没有走过的，1为黑棋，2为白棋
			currentChess: true,//目前正要下的棋子的颜色，初始化为true表示黑子棋子。false表示白色棋子
			over: false,//标志游戏是否结束，有一方赢了就表示结束
			num: 0,//已下棋子数目，设置在全局，为了悔棋功能而设;单数为黑子，偶数为白子
			count: 0,//赢棋个数统计，5
			chessX: [],//储存已下步数的横坐标，用于悔棋与撤销
			chessY: [],//储存已下步数的纵坐标，用于悔棋与撤销
			wins: [],//赢法数组，用来记录所有可能的赢法方案，
			blackWin: [],//赢法的统计数组，分别统计黑棋和白棋在上面所有赢法方案中已经完成了几颗棋子了
			whiteWin: []
		}


		//初始化棋盘信息，将二维数组所有项全部初始化为0
		for (var i = 0; i < 15; i++) {
			config.chessBoard[i] = [];
			for (var j = 0; j < 15; j++) {
				config.chessBoard[i][j] = 0;
			}
		}

		//初始化枚举赢法的数组，为一个三维数组
		for (var i = 0; i < 15; i++) {
			config.wins[i] = [];
			for (var j = 0; j < 15; j++) {
				config.wins[i][j] = [];
			}
		}

		//枚举所有可能的五个棋子竖直排列的情况
		for (var i = 0; i < 15; i++) {
			for (var j = 0; j < 11; j++) {
				for (var k = 0; k < 5; k++) {
					config.wins[i][j + k][config.count] = true;
				}
				config.count++;
			}
		}

		//枚举所有可能的五个棋子水平排列的情况
		for (var i = 0; i < 15; i++) {
			for (var j = 0; j < 11; j++) {
				for (var k = 0; k < 5; k++) {
					config.wins[j + k][i][config.count] = true;
				}
				config.count++;
			}
		}


		//枚举所有可能的五个棋子反斜线排列的情况
		for (var i = 0; i < 11; i++) {
			for (var j = 0; j < 11; j++) {
				for (var k = 0; k < 5; k++) {
					config.wins[i + k][j + k][config.count] = true;
				}
				config.count++;
			}
		}

		//枚举所有可能的五个棋子正斜线排列的情况
		for (var i = 0; i < 11; i++) {
			for (var j = 14; j > 3; j--) {
				for (var k = 0; k < 5; k++) {
					config.wins[i + k][j - k][config.count] = true;
				}
				config.count++;
			}
		}


		//分别初始化黑白两棋子在某种赢法的情况下已经有的棋子为0
		for (var i = 0; i < config.count; i++) {
			config.blackWin[i] = 0;
			config.whiteWin[i] = 0;
		}


		var chess = $('#chess')[0],//获取棋盘在dom中的元素,做一个棋子板
			bgchess = $('#bgchess')[0],//做一个背景板
			context = chess.getContext('2d'),
			bgcontext = bgchess.getContext('2d');

		context.strokeStyle = "#BFBFBF";



		//画棋盘格14*14=196格
		var drawChessBoard = function () {
			for (var i = 0; i < 15; i++) {
				bgcontext.moveTo(15 + i * 30, 15);
				bgcontext.lineTo(15 + i * 30, 435);
				bgcontext.moveTo(15, 15 + i * 30);
				bgcontext.lineTo(435, 15 + i * 30);
				bgcontext.stroke();
			}
		}


		/*在某个位置画一颗棋子
		@para i 横向第i个格子线
		@para j 纵向第j个格子线
		*/
		var drawChess = function (i, j) {

			config.num++;//已下棋子数加1

			context.beginPath();
			context.arc(15 + i * 30, 15 + j * 30, 13, 0, 2 * Math.PI);
			context.closePath();
			var gradient = context.createRadialGradient(15 + i * 30, 15 + j * 30, 13, 15 + i * 30, 15 + j * 30, 0);
			if (config.currentChess) {//设置黑棋子渐变颜色
				gradient.addColorStop(0, "#0A0A0A");
				gradient.addColorStop(1, "#636766");
			} else {//设置白棋子渐变颜色
				gradient.addColorStop(0, "#D1D1D1");
				gradient.addColorStop(1, "#F9F9F9");
			}

			context.fillStyle = gradient;
			context.fill();
		}

		/*
		设置鼠标点击处理事件
		*/
		chess.onclick = function (e) {
			if (config.over) {
				alert("本轮游戏已经结束了，请刷新浏览器重新开始！");
				return;
			}

			//获取点击的位置相当于棋盘左上角的位置
			var x = e.offsetX;
			var y = e.offsetY;

			var i = Math.floor(x / 30);
			var j = Math.floor(y / 30);


			if (config.chessBoard[i][j] === 0) {//在画棋子之前先判断一下棋盘上该位置是否已经有了棋子，为空时才允许放置
				drawChess(i, j);//画棋子
				if (config.currentChess) {//如果放下的棋子为黑棋

					config.chessX.push(i);//存入棋子的横纵坐标
					config.chessY.push(j);

					config.chessBoard[i][j] = 1;
					for (var k = 0; k < config.count; k++) {//遍历所有赢法
						if (config.wins[i][j][k]) {
							config.blackWin[k]++;
							config.whiteWin[k] = undefined;
							if (config.blackWin[k] === 5) {//如果黑棋在第k中赢法中已经有了5颗棋子，说明黑棋赢了
								alert('黑棋赢了！\r\n 应聘者：黄俊豪，职位：前端开发，电话：131-4584-2547');
								config.over = true;
							}
						}
					}
				} else {//如果放下的棋子为白棋

					config.chessX.push(i);//存入棋子的横纵坐标
					config.chessY.push(j);

					config.chessBoard[i][j] = 2;
					for (var k = 0; k < config.count; k++) {
						if (config.wins[i][j][k]) {
							config.whiteWin[k]++;
							config.blackWin[k] = undefined;
							if (config.whiteWin[k] === 5) {//如果白棋在第k中赢法中已经有了5颗棋子,说明白棋赢了
								alert('白棋赢了！\r\n 应聘者：黄俊豪，职位：前端开发，电话：131-4584-2547');
								config.over = true;
							}
						}
					}
				}
				config.currentChess = !config.currentChess;//将下一步棋的颜色进行反转		
			}

		}


		//悔棋事件
		var revert = function () {
			if (!config.over && config.num != 0) {
				i = config.chessX[config.num - 1];//取得最近一步棋子的横纵坐标，不用pop，因为还有撤销功能
				j = config.chessY[config.num - 1];

				context.clearRect(i * 30, j * 30, 30, 30);//干掉颜色，这个只干掉棋子板的，不会干掉背景板的

				config.chessBoard[i][j] = 0;
				if (!config.currentChess) {//把胜利统计减掉
					for (var k = 0; k < config.count; k++) {
						if (config.wins[i][j][k]) {
							config.blackWin[k]--;
						}
					}
				} else {
					for (var k = 0; k < config.count; k++) {
						if (config.wins[i][j][k]) {
							config.whiteWin[k]--;
						}
					}
				}
				config.currentChess = !config.currentChess;

				config.num--;//已下棋子数要减1
			} else {
				alert('悔无可悔！\r\n 应聘者：黄俊豪，职位：前端开发，电话：131-4584-2547');
			}
		}

		//撤销悔棋事件
		var removeRevert = function () {
			if (!config.over && config.chessX[config.num] != undefined) {
				i = config.chessX[config.num];//撤销到之前那一步，不要num++，因为drawChess里面有num++这个函数，自动加1
				j = config.chessY[config.num];
				if (config.currentChess) {
					if (config.chessBoard[i][j] == 0) {
						drawChess(i, j);
						config.chessBoard[i][j] = 1;//黑子
						for (var k = 0; k < config.count; k++) {
							if (config.wins[i][j][k]) {
								config.blackWin[k]++;
							}
						}

					}
				} else {
					if (config.chessBoard[i][j] == 0) {
						drawChess(i, j);
						config.chessBoard[i][j] = 2;//白子
						for (var k = 0; k < config.count; k++) {
							if (config.wins[i][j][k]) {
								config.whiteWin[k]++;
							}
						}
					}
				}
				config.currentChess = !config.currentChess;
			}
		}


		//初始化棋盘
		drawChessBoard();
	</script>
</body>

</html>